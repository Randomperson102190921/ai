<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Editing Knowledge Base with Code Generation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --success: #4cc9f0;
            --light: #f8f9fa;
            --dark: #212529;
            --gray: #6c757d;
            --light-gray: #e9ecef;
            --border: #dee2e6;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --pdf-color: #d72638;
            --code-color: #2a9d8f;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fb;
            color: var(--dark);
            line-height: 1.6;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-radius: 10px;
            box-shadow: var(--shadow);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }
        
        @media (max-width: 992px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: white;
            border-radius: 10px;
            box-shadow: var(--shadow);
            padding: 25px;
            margin-bottom: 25px;
        }
        
        .card-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card-title i {
            font-size: 1.8rem;
        }
        
        .input-group {
            display: flex;
            margin-bottom: 20px;
            gap: 10px;
        }
        
        input, textarea, button, select {
            padding: 12px 15px;
            border: 1px solid var(--border);
            border-radius: 5px;
            font-size: 1rem;
        }
        
        input, textarea, select {
            flex: 1;
        }
        
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: 600;
            min-width: 120px;
        }
        
        button:hover {
            background-color: var(--secondary);
        }
        
        button.secondary {
            background-color: var(--gray);
        }
        
        button.secondary:hover {
            background-color: #5a6268;
        }
        
        button.pdf-btn {
            background-color: var(--pdf-color);
        }
        
        button.pdf-btn:hover {
            background-color: #b51e2d;
        }
        
        button.code-btn {
            background-color: var(--code-color);
        }
        
        button.code-btn:hover {
            background-color: #218c74;
        }
        
        .kb-display {
            max-height: 500px;
            overflow-y: auto;
            padding: 15px;
            background-color: var(--light-gray);
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .topic {
            margin-left: 20px;
            border-left: 2px solid var(--primary);
            padding-left: 15px;
        }
        
        .fact {
            margin: 5px 0 5px 20px;
            padding: 5px 10px;
            background-color: white;
            border-radius: 5px;
            border-left: 3px solid var(--success);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 15px 0;
            text-align: center;
            font-weight: 500;
        }
        
        .status.success {
            background-color: rgba(76, 201, 240, 0.2);
            color: #0d6efd;
            border: 1px solid rgba(13, 110, 253, 0.3);
        }
        
        .status.error {
            background-color: rgba(220, 53, 69, 0.1);
            color: #dc3545;
            border: 1px solid rgba(220, 53, 69, 0.3);
        }
        
        .status.processing {
            background-color: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.3);
        }
        
        .question-section {
            margin-top: 20px;
        }
        
        .answer-box {
            min-height: 100px;
            padding: 15px;
            background-color: white;
            border: 1px solid var(--border);
            border-radius: 5px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .history-item {
            padding: 10px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .history-item:hover {
            background-color: var(--light-gray);
        }
        
        .history-item:last-child {
            border-bottom: none;
        }
        
        .empty-state {
            text-align: center;
            padding: 30px;
            color: var(--gray);
        }
        
        .empty-state i {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.3;
        }
        
        .pdf-section {
            background-color: #fff8f8;
            border: 1px dashed var(--pdf-color);
            border-radius: 5px;
            padding: 20px;
            margin-top: 20px;
            text-align: center;
        }
        
        .pdf-section h3 {
            color: var(--pdf-color);
            margin-bottom: 15px;
        }
        
        .pdf-drop-area {
            border: 2px dashed var(--pdf-color);
            border-radius: 5px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .pdf-drop-area:hover {
            background-color: #fff0f0;
        }
        
        .pdf-drop-area.highlight {
            background-color: #ffe0e0;
            border-color: #ff0000;
        }
        
        .pdf-preview {
            margin-top: 15px;
            padding: 15px;
            background-color: var(--light-gray);
            border-radius: 5px;
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .pdf-fact {
            margin: 5px 0;
            padding: 8px;
            background-color: white;
            border-radius: 4px;
            border-left: 3px solid var(--pdf-color);
        }
        
        .progress-container {
            margin-top: 15px;
        }
        
        .progress-bar {
            height: 10px;
            background-color: var(--light-gray);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: var(--primary);
            width: 0%;
            transition: width 0.3s;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            color: var(--gray);
            font-size: 0.9rem;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .code-section {
            background-color: #f0f7f4;
            border: 1px dashed var(--code-color);
            border-radius: 5px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .code-section h3 {
            color: var(--code-color);
            margin-bottom: 15px;
        }
        
        .code-editor {
            width: 100%;
            min-height: 150px;
            font-family: monospace;
            padding: 15px;
            border: 1px solid var(--border);
            border-radius: 5px;
            background-color: #f8f9fa;
            margin-bottom: 15px;
        }
        
        .code-output {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border);
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background-color: var(--light-gray);
            border: 1px solid var(--border);
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }
        
        .tab.active {
            background-color: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <header>
        <h1>Self-Editing Knowledge Base</h1>
        <p class="subtitle">Organize information and generate code from knowledge</p>
    </header>
    
    <div class="container">
        <div class="left-column">
            <div class="card">
                <h2 class="card-title">Knowledge Input</h2>
                
                <div class="tabs">
                    <div class="tab active" data-tab="text">Text Input</div>
                    <div class="tab" data-tab="pdf">PDF Upload</div>
                    <div class="tab" data-tab="code">Code Generation</div>
                </div>
                
                <div class="tab-content active" id="text-tab">
                    <div class="input-group">
                        <input type="text" id="factInput" placeholder="Enter a fact or information...">
                        <button id="addFactBtn">Add Fact</button>
                    </div>
                </div>
                
                <div class="tab-content" id="pdf-tab">
                    <div class="pdf-section">
                        <h3>Upload PDF Document</h3>
                        <div class="pdf-drop-area" id="pdfDropArea">
                            <p>Drag & drop a PDF file here or click to select</p>
                            <p><small>PDF will be processed and converted to facts</small></p>
                            <div class="file-input-wrapper">
                                <button class="pdf-btn">Select PDF</button>
                                <input type="file" id="pdfFileInput" accept=".pdf">
                            </div>
                        </div>
                        <div class="progress-container" id="pdfProgressContainer" style="display: none;">
                            <div class="progress-bar">
                                <div class="progress-fill" id="pdfProgressFill"></div>
                            </div>
                            <p id="pdfProgressText">Processing PDF...</p>
                        </div>
                        <div id="pdfPreview" class="pdf-preview" style="display: none;"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="code-tab">
                    <div class="code-section">
                        <h3>Generate Code from Knowledge</h3>
                        <textarea class="code-editor" id="codePrompt" placeholder="Describe what you want to generate (e.g., 'Create a function to calculate BMI')"></textarea>
                        <button id="generateCodeBtn" class="code-btn">Generate Code</button>
                        <div class="code-output" id="codeOutput">Generated code will appear here...</div>
                    </div>
                </div>
                
                <div class="status" id="statusMessage"></div>
                
                <div class="question-section">
                    <h3>Ask a Question</h3>
                    <div class="input-group">
                        <input type="text" id="questionInput" placeholder="Ask about topics or facts...">
                        <button id="askBtn">Ask</button>
                    </div>
                    <div class="answer-box" id="answerBox">
                        Your answer will appear here...
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2 class="card-title">Knowledge History</h2>
                <div id="historyList">
                    <div class="empty-state">
                        <i>📝</i>
                        <p>No facts added yet</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="right-column">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 class="card-title">Knowledge Structure</h2>
                    <div>
                        <button id="saveBtn" class="secondary">Save</button>
                        <button id="clearBtn" class="secondary">Clear All</button>
                    </div>
                </div>
                <div class="kb-display" id="kbDisplay">
                    <!-- Knowledge base structure will be displayed here -->
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        <p>Self-Editing Knowledge Base System | Uses TF-IDF & Cosine Similarity for categorization | PDF processing with pdf.js</p>
    </footer>

    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

        // Semantic Analyzer class for calculating similarity
        class SemanticAnalyzer {
            constructor() {
                this.documents = [];
                this.vocabulary = new Set();
            }

            preprocess(text) {
                return text
                    .toLowerCase()
                    .replace(/[^\w\s]/g, '')
                    .split(/\s+/)
                    .filter(word => word.length > 0);
            }

            addDocument(text) {
                const words = this.preprocess(text);
                this.documents.push(words);
                words.forEach(word => this.vocabulary.add(word));
            }

            getTf(word, doc) {
                const count = doc.filter(w => w === word).length;
                return count / doc.length;
            }

            getIdf(word) {
                const numDocsContainingWord = this.documents.filter(doc => doc.includes(word)).length;
                if (numDocsContainingWord === 0) return 0;
                return Math.log(this.documents.length / numDocsContainingWord);
            }

            getTfIdfVector(text) {
                const doc = this.preprocess(text);
                const vector = [];
                [...this.vocabulary].forEach(word => {
                    const tf = this.getTf(word, doc);
                    const idf = this.getIdf(word);
                    vector.push(tf * idf);
                });
                return vector;
            }

            cosineSimilarity(vecA, vecB) {
                if (vecA.length !== vecB.length) return 0;

                let dotProduct = 0;
                let magnitudeA = 0;
                let magnitudeB = 0;

                for (let i = 0; i < vecA.length; i++) {
                    dotProduct += vecA[i] * vecB[i];
                    magnitudeA += vecA[i] * vecA[i];
                    magnitudeB += vecB[i] * vecB[i];
                }

                magnitudeA = Math.sqrt(magnitudeA);
                magnitudeB = Math.sqrt(magnitudeB);

                if (magnitudeA === 0 || magnitudeB === 0) return 0;

                return dotProduct / (magnitudeA * magnitudeB);
            }

            getSimilarity(text1, text2) {
                if (!this.documents.some(doc => doc.join(' ') === this.preprocess(text1).join(' '))) {
                    this.addDocument(text1);
                }
                if (!this.documents.some(doc => doc.join(' ') === this.preprocess(text2).join(' '))) {
                    this.addDocument(text2);
                }

                const vec1 = this.getTfIdfVector(text1);
                const vec2 = this.getTfIdfVector(text2);
                return this.cosineSimilarity(vec1, vec2);
            }
        }

        // Knowledge Base class
        class KnowledgeBase {
            constructor() {
                this.data = [];
                this.analyzer = new SemanticAnalyzer();
                this.SIMILARITY_THRESHOLD = 0.1;
                this.loadFromStorage();
            }

            insertFact(fact) {
                this.analyzer.addDocument(fact);
                const bestMatch = this.findBestMatch(fact, this.data, []);

                if (bestMatch.score > this.SIMILARITY_THRESHOLD) {
                    let currentLevel = this.data;
                    for (const topicName of bestMatch.topicPath) {
                        let topicNode = currentLevel.find(node => typeof node === 'object' && node.topic === topicName);
                        if (!topicNode) {
                            topicNode = { topic: topicName, sub: [] };
                            currentLevel.push(topicNode);
                        }
                        currentLevel = topicNode.sub;
                    }
                    currentLevel.push(fact);
                } else {
                    const newTopicName = this.generateTopicName(fact);
                    this.data.push({
                        topic: newTopicName,
                        sub: [fact]
                    });
                }
                
                this.saveToStorage();
            }

            findBestMatch(fact, dataArray, currentPath) {
                let bestResult = { score: -1, topicPath: [] };

                for (const item of dataArray) {
                    if (typeof item === 'object' && item.topic) {
                        const similarity = this.analyzer.getSimilarity(fact, item.topic);
                        if (similarity > bestResult.score) {
                            bestResult.score = similarity;
                            bestResult.topicPath = [...currentPath, item.topic];
                        }
                        const subResult = this.findBestMatch(fact, item.sub, [...currentPath, item.topic]);
                        if (subResult.score > bestResult.score) {
                            bestResult = subResult;
                        }
                    }
                }
                return bestResult;
            }

            generateTopicName(fact) {
                const words = this.analyzer.preprocess(fact);
                return words.slice(0, Math.min(3, Math.max(1, Math.floor(words.length / 2)))).join(' ');
            }

            findTopics(query) {
                const results = [];

                const search = (dataArray, currentPath) => {
                    for (const item of dataArray) {
                        if (typeof item === 'object' && item.topic) {
                            const fullPath = [...currentPath, item.topic];
                            if (item.topic.toLowerCase().includes(query.toLowerCase())) {
                                results.push(fullPath);
                            }
                            search(item.sub, fullPath);
                        }
                    }
                };

                search(this.data, []);
                return results;
            }

            // Simple search for facts containing a query
            searchFacts(query) {
                const results = [];
                
                const search = (dataArray) => {
                    for (const item of dataArray) {
                        if (typeof item === 'string' && item.toLowerCase().includes(query.toLowerCase())) {
                            results.push(item);
                        } else if (typeof item === 'object' && item.topic) {
                            search(item.sub);
                        }
                    }
                };
                
                search(this.data);
                return results;
            }

            // Get all facts in the knowledge base
            getAllFacts() {
                const facts = [];
                
                const collect = (dataArray) => {
                    for (const item of dataArray) {
                        if (typeof item === 'string') {
                            facts.push(item);
                        } else if (typeof item === 'object' && item.topic) {
                            collect(item.sub);
                        }
                    }
                };
                
                collect(this.data);
                return facts;
            }

            // Get all topics in the knowledge base
            getAllTopics() {
                const topics = [];
                
                const collect = (dataArray) => {
                    for (const item of dataArray) {
                        if (typeof item === 'object' && item.topic) {
                            topics.push(item.topic);
                            collect(item.sub);
                        }
                    }
                };
                
                collect(this.data);
                return topics;
            }

            saveToStorage() {
                try {
                    localStorage.setItem('knowledgeBase', JSON.stringify({
                        data: this.data,
                        documents: Array.from(this.analyzer.documents),
                        vocabulary: Array.from(this.analyzer.vocabulary)
                    }));
                } catch (e) {
                    console.error("Failed to save to localStorage", e);
                }
            }

            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('knowledgeBase');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        this.data = parsed.data || [];
                        this.analyzer.documents = parsed.documents ? parsed.documents.map(d => Array.isArray(d) ? d : []) : [];
                        this.analyzer.vocabulary = new Set(parsed.vocabulary || []);
                    }
                } catch (e) {
                    console.error("Failed to load from localStorage", e);
                    this.data = [];
                }
            }

            clear() {
                this.data = [];
                this.analyzer = new SemanticAnalyzer();
                localStorage.removeItem('knowledgeBase');
            }
        }

        // PDF Processor class
        class PDFProcessor {
            constructor() {
                this.worker = null;
            }

            async extractText(file) {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const numPages = pdf.numPages;
                let textContent = '';

                for (let i = 1; i <= numPages; i++) {
                    const page = await pdf.getPage(i);
                    const text = await page.getTextContent();
                    const pageText = text.items.map(item => item.str).join(' ');
                    textContent += pageText + '\n\n';
                }

                return textContent;
            }

            // Split text into facts (simplified approach)
            splitIntoFacts(text) {
                // Split by sentences (basic approach)
                const sentences = text
                    .split(/(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?|\!)\s+/g)
                    .filter(sentence => sentence.trim().length > 10); // Filter out very short fragments
                
                // Group sentences into facts (3-5 sentences per fact)
                const facts = [];
                for (let i = 0; i < sentences.length; i += 4) {
                    const factGroup = sentences.slice(i, i + 4);
                    facts.push(factGroup.join(' ').trim());
                }
                
                return facts;
            }
        }

        // Code Generator class
        class CodeGenerator {
            constructor(knowledgeBase) {
                this.kb = knowledgeBase;
            }

            generateCode(prompt) {
                // Simple code generation based on prompt and knowledge base
                const facts = this.kb.getAllFacts();
                const topics = this.kb.getAllTopics();
                
                // Determine the type of code to generate based on prompt
                if (prompt.toLowerCase().includes('function')) {
                    return this.generateFunction(prompt, facts, topics);
                } else if (prompt.toLowerCase().includes('class')) {
                    return this.generateClass(prompt, facts, topics);
                } else if (prompt.toLowerCase().includes('algorithm') || prompt.toLowerCase().includes('calculate')) {
                    return this.generateAlgorithm(prompt, facts, topics);
                } else {
                    return this.generateGenericCode(prompt, facts, topics);
                }
            }

            generateFunction(prompt, facts, topics) {
                // Extract function name from prompt
                const funcNameMatch = prompt.match(/(?:create|generate|make).*?function.*?([a-zA-Z_]\w*)/i);
                const funcName = funcNameMatch ? funcNameMatch[1] : 'myFunction';
                
                // Extract parameters from prompt
                let params = '';
                if (prompt.includes('BMI') || prompt.includes('body mass')) {
                    params = 'weight, height';
                } else if (prompt.includes('area') || prompt.includes('rectangle')) {
                    params = 'length, width';
                } else if (prompt.includes('factorial')) {
                    params = 'n';
                } else {
                    params = 'a, b';
                }
                
                // Generate function body based on knowledge
                let body = '';
                if (prompt.includes('BMI')) {
                    body = `    // Calculate BMI based on weight (kg) and height (m)\n    const bmi = weight / (height * height);\n    return bmi;`;
                } else if (prompt.includes('area') || prompt.includes('rectangle')) {
                    body = `    // Calculate area of rectangle\n    return length * width;`;
                } else if (prompt.includes('factorial')) {
                    body = `    // Calculate factorial of n\n    if (n <= 1) return 1;\n    return n * factorial(n - 1);`;
                } else {
                    body = `    // Generic function implementation\n    // Based on knowledge: ${facts.slice(0, 2).join(', ')}\n    return a + b;`;
                }
                
                return `function ${funcName}(${params}) {\n${body}\n}`;
            }

            generateClass(prompt, facts, topics) {
                // Extract class name from prompt
                const classNameMatch = prompt.match(/(?:create|generate|make).*?class.*?([a-zA-Z_]\w*)/i);
                const className = classNameMatch ? classNameMatch[1] : 'MyClass';
                
                // Generate class with properties and methods
                return `class ${className} {\n    constructor() {\n        // Initialize properties based on knowledge\n        this.data = [];\n        this.timestamp = new Date();\n    }\n    \n    // Method based on knowledge: ${topics[0] || 'general'}\n    processData() {\n        // Implementation based on: ${facts[0] || 'available data'}\n        return this.data;\n    }\n}`;
            }

            generateAlgorithm(prompt, facts, topics) {
                if (prompt.includes('sort')) {
                    return `// Bubble sort algorithm\nfunction bubbleSort(arr) {\n    const n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // Swap elements\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    return arr;\n}`;
                } else if (prompt.includes('search') || prompt.includes('find')) {
                    return `// Binary search algorithm\nfunction binarySearch(arr, target) {\n    let left = 0;\n    let right = arr.length - 1;\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        \n        if (arr[mid] === target) {\n            return mid; // Found target\n        } else if (arr[mid] < target) {\n            left = mid + 1; // Search right half\n        } else {\n            right = mid - 1; // Search left half\n        }\n    }\n    \n    return -1; // Target not found\n}`;
                } else {
                    return `// Generic algorithm implementation\nfunction myAlgorithm(data) {\n    // Based on knowledge: ${facts.slice(0, 2).join(', ')}\n    // Implementation would go here\n    return data;\n}`;
                }
            }

            generateGenericCode(prompt, facts, topics) {
                // Generate a generic code snippet
                return `// Generated code based on: "${prompt}"\n// Related topics: ${topics.slice(0, 3).join(', ')}\n\nconst data = [${facts.slice(0, 3).map(f => `"${f.split(' ')[0]}"`).join(', ')}];\n\nfunction processData(input) {\n    // Implementation based on available knowledge\n    return input.map(item => item.toUpperCase());\n}\n\nconsole.log(processData(data));`;
            }
        }

        // UI Controller
        class UIController {
            constructor() {
                this.kb = new KnowledgeBase();
                this.pdfProcessor = new PDFProcessor();
                this.codeGenerator = new CodeGenerator(this.kb);
                this.initElements();
                this.bindEvents();
                this.renderKnowledgeBase();
                this.renderHistory();
            }

            initElements() {
                this.factInput = document.getElementById('factInput');
                this.addFactBtn = document.getElementById('addFactBtn');
                this.questionInput = document.getElementById('questionInput');
                this.askBtn = document.getElementById('askBtn');
                this.kbDisplay = document.getElementById('kbDisplay');
                this.answerBox = document.getElementById('answerBox');
                this.statusMessage = document.getElementById('statusMessage');
                this.historyList = document.getElementById('historyList');
                this.saveBtn = document.getElementById('saveBtn');
                this.clearBtn = document.getElementById('clearBtn');
                this.pdfFileInput = document.getElementById('pdfFileInput');
                this.pdfDropArea = document.getElementById('pdfDropArea');
                this.pdfPreview = document.getElementById('pdfPreview');
                this.pdfProgressContainer = document.getElementById('pdfProgressContainer');
                this.pdfProgressFill = document.getElementById('pdfProgressFill');
                this.pdfProgressText = document.getElementById('pdfProgressText');
                this.codePrompt = document.getElementById('codePrompt');
                this.generateCodeBtn = document.getElementById('generateCodeBtn');
                this.codeOutput = document.getElementById('codeOutput');
                this.tabs = document.querySelectorAll('.tab');
                this.tabContents = document.querySelectorAll('.tab-content');
            }

            bindEvents() {
                this.addFactBtn.addEventListener('click', () => this.handleAddFact());
                this.factInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.handleAddFact();
                });
                
                this.askBtn.addEventListener('click', () => this.handleAskQuestion());
                this.questionInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.handleAskQuestion();
                });
                
                this.saveBtn.addEventListener('click', () => this.handleSave());
                this.clearBtn.addEventListener('click', () => this.handleClear());
                
                // PDF events
                this.pdfFileInput.addEventListener('change', (e) => this.handlePDFUpload(e));
                
                // Drag and drop events
                this.pdfDropArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.pdfDropArea.classList.add('highlight');
                });
                
                this.pdfDropArea.addEventListener('dragleave', () => {
                    this.pdfDropArea.classList.remove('highlight');
                });
                
                this.pdfDropArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.pdfDropArea.classList.remove('highlight');
                    if (e.dataTransfer.files.length) {
                        this.processPDFFile(e.dataTransfer.files[0]);
                    }
                });
                
                // Code generation events
                this.generateCodeBtn.addEventListener('click', () => this.handleGenerateCode());
                
                // Tab switching
                this.tabs.forEach(tab => {
                    tab.addEventListener('click', () => this.switchTab(tab));
                });
            }

            switchTab(selectedTab) {
                // Remove active class from all tabs and contents
                this.tabs.forEach(tab => tab.classList.remove('active'));
                this.tabContents.forEach(content => content.classList.remove('active'));
                
                // Add active class to selected tab and corresponding content
                selectedTab.classList.add('active');
                const tabId = selectedTab.getAttribute('data-tab');
                document.getElementById(`${tabId}-tab`).classList.add('active');
            }

            handleAddFact() {
                const fact = this.factInput.value.trim();
                if (!fact) {
                    this.showStatus('Please enter a fact', 'error');
                    return;
                }
                
                this.kb.insertFact(fact);
                this.factInput.value = '';
                this.renderKnowledgeBase();
                this.renderHistory();
                this.showStatus(`Added: "${fact}"`, 'success');
            }

            async handlePDFUpload(event) {
                const file = event.target.files[0];
                if (file && file.type === 'application/pdf') {
                    await this.processPDFFile(file);
                } else {
                    this.showStatus('Please select a valid PDF file', 'error');
                }
            }

            async processPDFFile(file) {
                try {
                    this.showStatus(`Processing PDF: ${file.name}`, 'processing');
                    this.pdfProgressContainer.style.display = 'block';
                    this.pdfProgressFill.style.width = '0%';
                    this.pdfProgressText.textContent = 'Loading PDF...';
                    
                    // Extract text from PDF
                    const text = await this.pdfProcessor.extractText(file);
                    this.pdfProgressFill.style.width = '50%';
                    this.pdfProgressText.textContent = 'Splitting into facts...';
                    
                    // Split into facts
                    const facts = this.pdfProcessor.splitIntoFacts(text);
                    this.pdfProgressFill.style.width = '80%';
                    this.pdfProgressText.textContent = `Adding ${facts.length} facts...`;
                    
                    // Add facts to knowledge base
                    let addedCount = 0;
                    for (const fact of facts) {
                        if (fact.trim().length > 10) {
                            this.kb.insertFact(fact);
                            addedCount++;
                        }
                    }
                    
                    this.pdfProgressFill.style.width = '100%';
                    this.pdfProgressText.textContent = `Processed ${addedCount} facts from ${file.name}`;
                    
                    // Update UI
                    this.renderKnowledgeBase();
                    this.renderHistory();
                    this.showStatus(`Added ${addedCount} facts from PDF: ${file.name}`, 'success');
                    
                    // Preview first few facts
                    this.pdfPreview.style.display = 'block';
                    this.pdfPreview.innerHTML = '<h4>Preview of extracted facts:</h4>';
                    facts.slice(0, 5).forEach(fact => {
                        const factElement = document.createElement('div');
                        factElement.className = 'pdf-fact';
                        factElement.textContent = fact;
                        this.pdfPreview.appendChild(factElement);
                    });
                    
                    // Hide progress after delay
                    setTimeout(() => {
                        this.pdfProgressContainer.style.display = 'none';
                        this.pdfPreview.style.display = 'none';
                    }, 5000);
                    
                } catch (error) {
                    console.error('Error processing PDF:', error);
                    this.showStatus(`Error processing PDF: ${error.message}`, 'error');
                    this.pdfProgressContainer.style.display = 'none';
                }
            }

            handleAskQuestion() {
                const question = this.questionInput.value.trim();
                if (!question) {
                    this.answerBox.textContent = 'Please enter a question';
                    return;
                }
                
                // Simple question answering logic
                const topics = this.kb.findTopics(question);
                const facts = this.kb.searchFacts(question);
                
                let answer = '';
                
                if (topics.length > 0) {
                    answer += `<strong>Topics related to "${question}":</strong>\n`;
                    topics.forEach(topicPath => {
                        answer += `- ${topicPath.join(' → ')}\n`;
                    });
                    answer += '\n';
                }
                
                if (facts.length > 0) {
                    answer += `<strong>Facts containing "${question}":</strong>\n`;
                    facts.slice(0, 5).forEach(fact => {
                        answer += `- ${fact}\n`;
                    });
                }
                
                if (!answer) {
                    // If no direct matches, find similar facts
                    const allFacts = this.kb.getAllFacts();
                    const similarities = allFacts.map(fact => ({
                        fact,
                        similarity: this.kb.analyzer.getSimilarity(question, fact)
                    })).sort((a, b) => b.similarity - a.similarity);
                    
                    const topMatches = similarities.filter(s => s.similarity > 0.1).slice(0, 3);
                    
                    if (topMatches.length > 0) {
                        answer = `<strong>Most similar facts to "${question}":</strong>\n`;
                        topMatches.forEach(match => {
                            answer += `- ${match.fact} (similarity: ${(match.similarity * 100).toFixed(1)}%)\n`;
                        });
                    } else {
                        answer = `I don't have specific information about "${question}". Try adding more facts to the knowledge base.`;
                    }
                }
                
                this.answerBox.innerHTML = answer.replace(/\n/g, '<br>');
            }

            handleGenerateCode() {
                const prompt = this.codePrompt.value.trim();
                if (!prompt) {
                    this.codeOutput.textContent = 'Please enter a code generation prompt';
                    return;
                }
                
                try {
                    const generatedCode = this.codeGenerator.generateCode(prompt);
                    this.codeOutput.textContent = generatedCode;
                    this.showStatus('Code generated successfully', 'success');
                } catch (error) {
                    this.codeOutput.textContent = `Error generating code: ${error.message}`;
                    this.showStatus('Error generating code', 'error');
                }
            }

            handleSave() {
                this.kb.saveToStorage();
                this.showStatus('Knowledge base saved to local storage', 'success');
            }

            handleClear() {
                if (confirm('Are you sure you want to clear all knowledge? This cannot be undone.')) {
                    this.kb.clear();
                    this.renderKnowledgeBase();
                    this.renderHistory();
                    this.showStatus('Knowledge base cleared', 'success');
                }
            }

            renderKnowledgeBase() {
                if (this.kb.data.length === 0) {
                    this.kbDisplay.innerHTML = '<div class="empty-state"><i>🧠</i><p>Knowledge base is empty</p></div>';
                    return;
                }
                
                const renderLevel = (items, level = 0) => {
                    let html = '';
                    items.forEach(item => {
                        if (typeof item === 'string') {
                            html += `<div class="fact">${item}</div>`;
                        } else if (typeof item === 'object' && item.topic) {
                            html += `<div class="topic"><strong>+ ${item.topic}</strong>`;
                            if (item.sub && item.sub.length > 0) {
                                html += renderLevel(item.sub, level + 1);
                            }
                            html += `</div>`;
                        }
                    });
                    return html;
                };
                
                this.kbDisplay.innerHTML = renderLevel(this.kb.data);
            }

            renderHistory() {
                const facts = this.kb.getAllFacts();
                
                if (facts.length === 0) {
                    this.historyList.innerHTML = '<div class="empty-state"><i>📝</i><p>No facts added yet</p></div>';
                    return;
                }
                
                // Show last 10 facts
                const recentFacts = facts.slice(-10).reverse();
                this.historyList.innerHTML = recentFacts.map(fact => 
                    `<div class="history-item" title="${fact}">${fact}</div>`
                ).join('');
                
                // Add click event to history items
                this.historyList.querySelectorAll('.history-item').forEach(item => {
                    item.addEventListener('click', () => {
                        this.questionInput.value = item.textContent;
                        this.handleAskQuestion();
                    });
                });
            }

            showStatus(message, type) {
                this.statusMessage.textContent = message;
                this.statusMessage.className = `status ${type}`;
                setTimeout(() => {
                    this.statusMessage.textContent = '';
                    this.statusMessage.className = 'status';
                }, 3000);
            }
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const app = new UIController();
        });
    </script>
</body>
</html>
